{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport isPromise from 'is-promise';\nimport SubmissionError from './SubmissionError';\nvar isSubmissionError = function isSubmissionError(error) {\n  return error && error.name === SubmissionError.name;\n};\nvar mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n    syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, syncErrors);\n};\nvar isImmutableList;\ntry {\n  // ImmutableJS isList implementation if available\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  var _require = require('immutable'),\n    List = _require.List;\n  isImmutableList = List.isList;\n} catch (err) {\n  isImmutableList = function isImmutableList(maybeList) {\n    return false;\n  };\n} // fields may be an Immutable List which cannot be spread\n// convert the fields to an array if necessary\n\nvar makeFieldsArray = function makeFieldsArray(fields) {\n  return isImmutableList(fields) ? fields.toArray() : fields;\n};\nvar executeSubmit = function executeSubmit(submit, fields, props) {\n  var dispatch = props.dispatch,\n    submitAsSideEffect = props.submitAsSideEffect,\n    onSubmitFail = props.onSubmitFail,\n    onSubmitSuccess = props.onSubmitSuccess,\n    startSubmit = props.startSubmit,\n    stopSubmit = props.stopSubmit,\n    setSubmitFailed = props.setSubmitFailed,\n    setSubmitSucceeded = props.setSubmitSucceeded,\n    values = props.values;\n  fields = makeFieldsArray(fields);\n  var result;\n  try {\n    result = submit(values, dispatch, props);\n  } catch (submitError) {\n    var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n    stopSubmit(error);\n    setSubmitFailed.apply(void 0, fields);\n    if (onSubmitFail) {\n      onSubmitFail(error, dispatch, submitError, props);\n    }\n    if (error || onSubmitFail) {\n      // if you've provided an onSubmitFail callback, don't re-throw the error\n      return error;\n    } else {\n      throw submitError;\n    }\n  }\n  if (submitAsSideEffect) {\n    if (result) {\n      dispatch(result);\n    }\n  } else {\n    if (isPromise(result)) {\n      startSubmit();\n      return result.then(function (submitResult) {\n        stopSubmit();\n        setSubmitSucceeded();\n        if (onSubmitSuccess) {\n          onSubmitSuccess(submitResult, dispatch, props);\n        }\n        return submitResult;\n      }, function (submitError) {\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n        if (error || onSubmitFail) {\n          // if you've provided an onSubmitFail callback, don't re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      });\n    } else {\n      setSubmitSucceeded();\n      if (onSubmitSuccess) {\n        onSubmitSuccess(result, dispatch, props);\n      }\n    }\n  }\n  return result;\n};\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n    onSubmitFail = props.onSubmitFail,\n    setSubmitFailed = props.setSubmitFailed,\n    syncErrors = props.syncErrors,\n    asyncErrors = props.asyncErrors,\n    touch = props.touch,\n    persistentSubmitErrors = props.persistentSubmitErrors;\n  fields = makeFieldsArray(fields);\n  touch.apply(void 0, fields); // mark all fields as touched\n\n  if (valid || persistentSubmitErrors) {\n    var asyncValidateResult = asyncValidate && asyncValidate();\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n        return executeSubmit(submit, fields, props);\n      })[\"catch\"](function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return executeSubmit(submit, fields, props);\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n    return errors;\n  }\n};\nexport default handleSubmit;","map":{"version":3,"names":["_extends","isPromise","SubmissionError","isSubmissionError","error","name","mergeErrors","_ref","asyncErrors","syncErrors","merge","toJS","isImmutableList","_require","require","List","isList","err","maybeList","makeFieldsArray","fields","toArray","executeSubmit","submit","props","dispatch","submitAsSideEffect","onSubmitFail","onSubmitSuccess","startSubmit","stopSubmit","setSubmitFailed","setSubmitSucceeded","values","result","submitError","errors","undefined","apply","then","submitResult","handleSubmit","valid","asyncValidate","touch","persistentSubmitErrors","asyncValidateResult","Promise","reject"],"sources":["C:/Users/yt988/OneDrive/Documents/My/Programming/Social-Network/node_modules/redux-form/es/handleSubmit.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport isPromise from 'is-promise';\nimport SubmissionError from './SubmissionError';\n\nvar isSubmissionError = function isSubmissionError(error) {\n  return error && error.name === SubmissionError.name;\n};\n\nvar mergeErrors = function mergeErrors(_ref) {\n  var asyncErrors = _ref.asyncErrors,\n      syncErrors = _ref.syncErrors;\n  return asyncErrors && typeof asyncErrors.merge === 'function' ? asyncErrors.merge(syncErrors).toJS() : _extends({}, asyncErrors, syncErrors);\n};\n\nvar isImmutableList;\n\ntry {\n  // ImmutableJS isList implementation if available\n  // eslint-disable-next-line import/no-extraneous-dependencies\n  var _require = require('immutable'),\n      List = _require.List;\n\n  isImmutableList = List.isList;\n} catch (err) {\n  isImmutableList = function isImmutableList(maybeList) {\n    return false;\n  };\n} // fields may be an Immutable List which cannot be spread\n// convert the fields to an array if necessary\n\n\nvar makeFieldsArray = function makeFieldsArray(fields) {\n  return isImmutableList(fields) ? fields.toArray() : fields;\n};\n\nvar executeSubmit = function executeSubmit(submit, fields, props) {\n  var dispatch = props.dispatch,\n      submitAsSideEffect = props.submitAsSideEffect,\n      onSubmitFail = props.onSubmitFail,\n      onSubmitSuccess = props.onSubmitSuccess,\n      startSubmit = props.startSubmit,\n      stopSubmit = props.stopSubmit,\n      setSubmitFailed = props.setSubmitFailed,\n      setSubmitSucceeded = props.setSubmitSucceeded,\n      values = props.values;\n  fields = makeFieldsArray(fields);\n  var result;\n\n  try {\n    result = submit(values, dispatch, props);\n  } catch (submitError) {\n    var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n    stopSubmit(error);\n    setSubmitFailed.apply(void 0, fields);\n\n    if (onSubmitFail) {\n      onSubmitFail(error, dispatch, submitError, props);\n    }\n\n    if (error || onSubmitFail) {\n      // if you've provided an onSubmitFail callback, don't re-throw the error\n      return error;\n    } else {\n      throw submitError;\n    }\n  }\n\n  if (submitAsSideEffect) {\n    if (result) {\n      dispatch(result);\n    }\n  } else {\n    if (isPromise(result)) {\n      startSubmit();\n      return result.then(function (submitResult) {\n        stopSubmit();\n        setSubmitSucceeded();\n\n        if (onSubmitSuccess) {\n          onSubmitSuccess(submitResult, dispatch, props);\n        }\n\n        return submitResult;\n      }, function (submitError) {\n        var error = isSubmissionError(submitError) ? submitError.errors : undefined;\n        stopSubmit(error);\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(error, dispatch, submitError, props);\n        }\n\n        if (error || onSubmitFail) {\n          // if you've provided an onSubmitFail callback, don't re-throw the error\n          return error;\n        } else {\n          throw submitError;\n        }\n      });\n    } else {\n      setSubmitSucceeded();\n\n      if (onSubmitSuccess) {\n        onSubmitSuccess(result, dispatch, props);\n      }\n    }\n  }\n\n  return result;\n};\n\nvar handleSubmit = function handleSubmit(submit, props, valid, asyncValidate, fields) {\n  var dispatch = props.dispatch,\n      onSubmitFail = props.onSubmitFail,\n      setSubmitFailed = props.setSubmitFailed,\n      syncErrors = props.syncErrors,\n      asyncErrors = props.asyncErrors,\n      touch = props.touch,\n      persistentSubmitErrors = props.persistentSubmitErrors;\n  fields = makeFieldsArray(fields);\n  touch.apply(void 0, fields); // mark all fields as touched\n\n  if (valid || persistentSubmitErrors) {\n    var asyncValidateResult = asyncValidate && asyncValidate();\n\n    if (asyncValidateResult) {\n      return asyncValidateResult.then(function (asyncErrors) {\n        if (asyncErrors) {\n          throw asyncErrors;\n        }\n\n        return executeSubmit(submit, fields, props);\n      })[\"catch\"](function (asyncErrors) {\n        setSubmitFailed.apply(void 0, fields);\n\n        if (onSubmitFail) {\n          onSubmitFail(asyncErrors, dispatch, null, props);\n        }\n\n        return Promise.reject(asyncErrors);\n      });\n    } else {\n      return executeSubmit(submit, fields, props);\n    }\n  } else {\n    setSubmitFailed.apply(void 0, fields);\n    var errors = mergeErrors({\n      asyncErrors: asyncErrors,\n      syncErrors: syncErrors\n    });\n\n    if (onSubmitFail) {\n      onSubmitFail(errors, dispatch, null, props);\n    }\n\n    return errors;\n  }\n};\n\nexport default handleSubmit;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}